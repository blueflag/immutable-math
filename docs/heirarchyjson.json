{"module":{"heading":"Modules","blocks":[{"comment":"/**\n * @module aggregations\n */","meta":{"range":[82,113],"filename":"aggregations.js","lineno":8,"path":"/Users/damienclarke/projects/immutable-math/src","code":{}},"kind":"module","name":"aggregations","longname":"module:aggregations","___id":"T000002R000028","___s":true,"blocks":[{"returns":[{"type":{"names":["InputFunction"],"typedefs":{"InputFunction":{"returns":[{"type":{"names":["Number"]},"description":"<p>The result of the function</p>"}],"meta":{"range":[3627,5224],"filename":"aggregations.js","lineno":123,"path":"/Users/damienclarke/projects/immutable-math/src","code":{}},"params":[{"type":{"names":["Iterable"]},"description":"<p>The input Iterable to be processed by one of the functions.</p>","name":"input"}],"longname":"module:aggregations~InputFunction","name":"InputFunction","memberof":"module:aggregations","scope":"inner","kind":"typedef","___s":true,"___id":"T000002R000040","type":{"names":["function"]},"description":"<p>InputFunction is a partially applied function returned from aggregations in immutable-math.\nIt accepts an <code>Iterable</code> of the data you wish to operate on,\nand returns the result of the function you're calling.</p>\n<p>For example, one way to use <code>average</code> is to call it, passing in any parameters required (<code>average requires no extra params</code>), then call the returned function passing in your data.</p>\n<pre class=\"prettyprint source lang-js\"><code>const numbers = fromJS([1,1,1,5]);\nreturn average()(numbers); // returns 2</code></pre><p>For any immutable-math functions that return an <code>Iterable</code>, this design of using a partially applied function allows for easy chaining by using them inside of an <code>update()</code> method, if your input <code>Iterable</code> has an update function.</p>\n<pre class=\"prettyprint source lang-js\"><code>return fromJS([1,1,1,5])\n    .update(exampleFunction()) // using an exampleFunction from immutable-math in a chain\n    .sort()\n    .toJS();</code></pre><p>You can also define a function to perform a specific operation, and use it multiple times by passing in different input data.</p>\n<pre class=\"prettyprint source lang-js\"><code>const numbersA = fromJS([\n {num: 1},\n {num: 1},\n {num: 1},\n {num: 5}\n]);\n\nconst numbersB = fromJS([\n {num: 3},\n {num: 5}\n]);\n\nconst averageByNum = averageBy(ii => ii.get('num'));\nconst averageA = numbersA.update(averageByNum); // averageA is 2\nconst averageB = numbersB.update(averageByNum); // averageB is 4</code></pre>","comment":"/**\n * InputFunction is a partially applied function returned from aggregations in immutable-math.\n * It accepts an `Iterable` of the data you wish to operate on,\n * and returns the result of the function you're calling.\n *\n * For example, one way to use `average` is to call it, passing in any parameters required (`average requires no extra params`), then call the returned function passing in your data.\n *\n * ```js\n * const numbers = fromJS([1,1,1,5]);\n * return average()(numbers); // returns 2\n * ```\n *\n * For any immutable-math functions that return an `Iterable`, this design of using a partially applied function allows for easy chaining by using them inside of an `update()` method, if your input `Iterable` has an update function.\n * \n * ```js\n * return fromJS([1,1,1,5])\n *     .update(exampleFunction()) // using an exampleFunction from immutable-math in a chain\n *     .sort()\n *     .toJS();\n * ```\n * \n *\n * You can also define a function to perform a specific operation, and use it multiple times by passing in different input data.\n * \n * \n *  ```js\n * const numbersA = fromJS([\n *  {num: 1},\n *  {num: 1},\n *  {num: 1},\n *  {num: 5}\n * ]);\n * \n * const numbersB = fromJS([\n *  {num: 3},\n *  {num: 5}\n * ]);\n * \n * const averageByNum = averageBy(ii => ii.get('num'));\n * const averageA = numbersA.update(averageByNum); // averageA is 2\n * const averageB = numbersB.update(averageByNum); // averageB is 4\n * ```\n *\n * @callback InputFunction\n * @param {Iterable} input The input Iterable to be processed by one of the functions.\n * @return {Number} The result of the function\n */"}}},"description":"<p>A partially applied function which accepts a single <code>Iterable</code>, and returns the result of the operation.</p>"}],"meta":{"range":[325,451],"filename":"aggregations.js","lineno":18,"path":"/Users/damienclarke/projects/immutable-math/src","code":{"id":"astnode100000787","name":"average","type":"FunctionDeclaration","paramnames":[]},"vars":{"":null}},"params":[],"longname":"module:aggregations~average","name":"average","memberof":"module:aggregations","scope":"inner","kind":"function","___s":true,"___id":"T000002R000030","description":"<p>Averages the elements in an <code>Iterable</code>. Accepts no parameters.</p>","comment":"/**\n * Averages the elements in an `Iterable`. Accepts no parameters.\n *\n * @return {InputFunction} A partially applied function which accepts a single `Iterable`, and returns the result of the operation.\n */"},{"returns":[{"type":{"names":["InputFunction"],"typedefs":{"InputFunction":{"returns":[{"type":{"names":["Number"]},"description":"<p>The result of the function</p>"}],"meta":{"range":[3627,5224],"filename":"aggregations.js","lineno":123,"path":"/Users/damienclarke/projects/immutable-math/src","code":{}},"params":[{"type":{"names":["Iterable"]},"description":"<p>The input Iterable to be processed by one of the functions.</p>","name":"input"}],"longname":"module:aggregations~InputFunction","name":"InputFunction","memberof":"module:aggregations","scope":"inner","kind":"typedef","___s":true,"___id":"T000002R000040","type":{"names":["function"]},"description":"<p>InputFunction is a partially applied function returned from aggregations in immutable-math.\nIt accepts an <code>Iterable</code> of the data you wish to operate on,\nand returns the result of the function you're calling.</p>\n<p>For example, one way to use <code>average</code> is to call it, passing in any parameters required (<code>average requires no extra params</code>), then call the returned function passing in your data.</p>\n<pre class=\"prettyprint source lang-js\"><code>const numbers = fromJS([1,1,1,5]);\nreturn average()(numbers); // returns 2</code></pre><p>For any immutable-math functions that return an <code>Iterable</code>, this design of using a partially applied function allows for easy chaining by using them inside of an <code>update()</code> method, if your input <code>Iterable</code> has an update function.</p>\n<pre class=\"prettyprint source lang-js\"><code>return fromJS([1,1,1,5])\n    .update(exampleFunction()) // using an exampleFunction from immutable-math in a chain\n    .sort()\n    .toJS();</code></pre><p>You can also define a function to perform a specific operation, and use it multiple times by passing in different input data.</p>\n<pre class=\"prettyprint source lang-js\"><code>const numbersA = fromJS([\n {num: 1},\n {num: 1},\n {num: 1},\n {num: 5}\n]);\n\nconst numbersB = fromJS([\n {num: 3},\n {num: 5}\n]);\n\nconst averageByNum = averageBy(ii => ii.get('num'));\nconst averageA = numbersA.update(averageByNum); // averageA is 2\nconst averageB = numbersB.update(averageByNum); // averageB is 4</code></pre>","comment":"/**\n * InputFunction is a partially applied function returned from aggregations in immutable-math.\n * It accepts an `Iterable` of the data you wish to operate on,\n * and returns the result of the function you're calling.\n *\n * For example, one way to use `average` is to call it, passing in any parameters required (`average requires no extra params`), then call the returned function passing in your data.\n *\n * ```js\n * const numbers = fromJS([1,1,1,5]);\n * return average()(numbers); // returns 2\n * ```\n *\n * For any immutable-math functions that return an `Iterable`, this design of using a partially applied function allows for easy chaining by using them inside of an `update()` method, if your input `Iterable` has an update function.\n * \n * ```js\n * return fromJS([1,1,1,5])\n *     .update(exampleFunction()) // using an exampleFunction from immutable-math in a chain\n *     .sort()\n *     .toJS();\n * ```\n * \n *\n * You can also define a function to perform a specific operation, and use it multiple times by passing in different input data.\n * \n * \n *  ```js\n * const numbersA = fromJS([\n *  {num: 1},\n *  {num: 1},\n *  {num: 1},\n *  {num: 5}\n * ]);\n * \n * const numbersB = fromJS([\n *  {num: 3},\n *  {num: 5}\n * ]);\n * \n * const averageByNum = averageBy(ii => ii.get('num'));\n * const averageA = numbersA.update(averageByNum); // averageA is 2\n * const averageB = numbersB.update(averageByNum); // averageB is 4\n * ```\n *\n * @callback InputFunction\n * @param {Iterable} input The input Iterable to be processed by one of the functions.\n * @return {Number} The result of the function\n */"}}},"description":"<p>A partially applied function which accepts a single <code>Iterable</code>, and returns the result of the operation.</p>"}],"meta":{"range":[851,965],"filename":"aggregations.js","lineno":31,"path":"/Users/damienclarke/projects/immutable-math/src","code":{"id":"astnode100000810","name":"averageBy","type":"FunctionDeclaration","paramnames":["valueMapper"]},"vars":{"":null}},"params":[{"type":{"names":["ValueMapper"],"typedefs":{"ValueMapper":{"returns":[{"type":{"names":["Number"]},"description":"<p>The number to use in the operation.</p>"}],"meta":{"range":[5226,5684],"filename":"aggregations.js","lineno":171,"path":"/Users/damienclarke/projects/immutable-math/src","code":{}},"params":[{"type":{"names":["*"]},"description":"<p>The value of the current item in the input <code>Iterable</code>.</p>","name":"value"},{"type":{"names":["*"]},"description":"<p>The key of the current item in the input <code>Iterable</code>.</p>","name":"key"},{"type":{"names":["Iterable"]},"description":"<p>The original <code>input</code> <code>Iterable</code>.</p>","name":"iter"}],"longname":"module:aggregations~ValueMapper","name":"ValueMapper","memberof":"module:aggregations","scope":"inner","kind":"typedef","___s":true,"___id":"T000002R000041","type":{"names":["function"]},"description":"<p>A function required by some operations that allows you to specify what value gets pulled from each item in the input <code>Iterable</code> when performing a calculation.</p>","comment":"/**\n * A function required by some operations that allows you to specify what value gets pulled from each item in the input `Iterable` when performing a calculation.\n *\n * @callback ValueMapper\n * @param {*} value The value of the current item in the input `Iterable`.\n * @param {*} key The key of the current item in the input `Iterable`.\n * @param {Iterable} iter The original `input` `Iterable`.\n * @return {Number} The number to use in the operation.\n */"}}},"description":"<p>A function that allows you to specify what value gets averaged on each item in the input <code>Iterable</code>.</p>","name":"valueMapper"}],"longname":"module:aggregations~averageBy","name":"averageBy","memberof":"module:aggregations","scope":"inner","kind":"function","___s":true,"___id":"T000002R000031","description":"<p>Like <code>average</code>, but also accepts a <code>valueMapper</code> function which allows for averaging by more sophisticated means.</p>","comment":"/**\n * Like `average`, but also accepts a `valueMapper` function which allows for averaging by more sophisticated means.\n *\n * @param {ValueMapper} valueMapper A function that allows you to specify what value gets averaged on each item in the input `Iterable`.\n * @return {InputFunction} A partially applied function which accepts a single `Iterable`, and returns the result of the operation.\n */"},{"returns":[{"type":{"names":["InputFunction"],"typedefs":{"InputFunction":{"returns":[{"type":{"names":["Number"]},"description":"<p>The result of the function</p>"}],"meta":{"range":[3627,5224],"filename":"aggregations.js","lineno":123,"path":"/Users/damienclarke/projects/immutable-math/src","code":{}},"params":[{"type":{"names":["Iterable"]},"description":"<p>The input Iterable to be processed by one of the functions.</p>","name":"input"}],"longname":"module:aggregations~InputFunction","name":"InputFunction","memberof":"module:aggregations","scope":"inner","kind":"typedef","___s":true,"___id":"T000002R000040","type":{"names":["function"]},"description":"<p>InputFunction is a partially applied function returned from aggregations in immutable-math.\nIt accepts an <code>Iterable</code> of the data you wish to operate on,\nand returns the result of the function you're calling.</p>\n<p>For example, one way to use <code>average</code> is to call it, passing in any parameters required (<code>average requires no extra params</code>), then call the returned function passing in your data.</p>\n<pre class=\"prettyprint source lang-js\"><code>const numbers = fromJS([1,1,1,5]);\nreturn average()(numbers); // returns 2</code></pre><p>For any immutable-math functions that return an <code>Iterable</code>, this design of using a partially applied function allows for easy chaining by using them inside of an <code>update()</code> method, if your input <code>Iterable</code> has an update function.</p>\n<pre class=\"prettyprint source lang-js\"><code>return fromJS([1,1,1,5])\n    .update(exampleFunction()) // using an exampleFunction from immutable-math in a chain\n    .sort()\n    .toJS();</code></pre><p>You can also define a function to perform a specific operation, and use it multiple times by passing in different input data.</p>\n<pre class=\"prettyprint source lang-js\"><code>const numbersA = fromJS([\n {num: 1},\n {num: 1},\n {num: 1},\n {num: 5}\n]);\n\nconst numbersB = fromJS([\n {num: 3},\n {num: 5}\n]);\n\nconst averageByNum = averageBy(ii => ii.get('num'));\nconst averageA = numbersA.update(averageByNum); // averageA is 2\nconst averageB = numbersB.update(averageByNum); // averageB is 4</code></pre>","comment":"/**\n * InputFunction is a partially applied function returned from aggregations in immutable-math.\n * It accepts an `Iterable` of the data you wish to operate on,\n * and returns the result of the function you're calling.\n *\n * For example, one way to use `average` is to call it, passing in any parameters required (`average requires no extra params`), then call the returned function passing in your data.\n *\n * ```js\n * const numbers = fromJS([1,1,1,5]);\n * return average()(numbers); // returns 2\n * ```\n *\n * For any immutable-math functions that return an `Iterable`, this design of using a partially applied function allows for easy chaining by using them inside of an `update()` method, if your input `Iterable` has an update function.\n * \n * ```js\n * return fromJS([1,1,1,5])\n *     .update(exampleFunction()) // using an exampleFunction from immutable-math in a chain\n *     .sort()\n *     .toJS();\n * ```\n * \n *\n * You can also define a function to perform a specific operation, and use it multiple times by passing in different input data.\n * \n * \n *  ```js\n * const numbersA = fromJS([\n *  {num: 1},\n *  {num: 1},\n *  {num: 1},\n *  {num: 5}\n * ]);\n * \n * const numbersB = fromJS([\n *  {num: 3},\n *  {num: 5}\n * ]);\n * \n * const averageByNum = averageBy(ii => ii.get('num'));\n * const averageA = numbersA.update(averageByNum); // averageA is 2\n * const averageB = numbersB.update(averageByNum); // averageB is 4\n * ```\n *\n * @callback InputFunction\n * @param {Iterable} input The input Iterable to be processed by one of the functions.\n * @return {Number} The result of the function\n */"}}},"description":"<p>A partially applied function which accepts a single <code>Iterable</code>, and returns the result of the operation.</p>"}],"meta":{"range":[1141,1180],"filename":"aggregations.js","lineno":42,"path":"/Users/damienclarke/projects/immutable-math/src","code":{"id":"astnode100000827","name":"mean","type":"FunctionDeclaration","paramnames":[]}},"params":[],"longname":"module:aggregations~mean","name":"mean","memberof":"module:aggregations","scope":"inner","kind":"function","___s":true,"___id":"T000002R000032","description":"<p>An alias for average.</p>","comment":"/**\n * An alias for average.\n * @return {InputFunction} A partially applied function which accepts a single `Iterable`, and returns the result of the operation.\n */"},{"returns":[{"type":{"names":["InputFunction"],"typedefs":{"InputFunction":{"returns":[{"type":{"names":["Number"]},"description":"<p>The result of the function</p>"}],"meta":{"range":[3627,5224],"filename":"aggregations.js","lineno":123,"path":"/Users/damienclarke/projects/immutable-math/src","code":{}},"params":[{"type":{"names":["Iterable"]},"description":"<p>The input Iterable to be processed by one of the functions.</p>","name":"input"}],"longname":"module:aggregations~InputFunction","name":"InputFunction","memberof":"module:aggregations","scope":"inner","kind":"typedef","___s":true,"___id":"T000002R000040","type":{"names":["function"]},"description":"<p>InputFunction is a partially applied function returned from aggregations in immutable-math.\nIt accepts an <code>Iterable</code> of the data you wish to operate on,\nand returns the result of the function you're calling.</p>\n<p>For example, one way to use <code>average</code> is to call it, passing in any parameters required (<code>average requires no extra params</code>), then call the returned function passing in your data.</p>\n<pre class=\"prettyprint source lang-js\"><code>const numbers = fromJS([1,1,1,5]);\nreturn average()(numbers); // returns 2</code></pre><p>For any immutable-math functions that return an <code>Iterable</code>, this design of using a partially applied function allows for easy chaining by using them inside of an <code>update()</code> method, if your input <code>Iterable</code> has an update function.</p>\n<pre class=\"prettyprint source lang-js\"><code>return fromJS([1,1,1,5])\n    .update(exampleFunction()) // using an exampleFunction from immutable-math in a chain\n    .sort()\n    .toJS();</code></pre><p>You can also define a function to perform a specific operation, and use it multiple times by passing in different input data.</p>\n<pre class=\"prettyprint source lang-js\"><code>const numbersA = fromJS([\n {num: 1},\n {num: 1},\n {num: 1},\n {num: 5}\n]);\n\nconst numbersB = fromJS([\n {num: 3},\n {num: 5}\n]);\n\nconst averageByNum = averageBy(ii => ii.get('num'));\nconst averageA = numbersA.update(averageByNum); // averageA is 2\nconst averageB = numbersB.update(averageByNum); // averageB is 4</code></pre>","comment":"/**\n * InputFunction is a partially applied function returned from aggregations in immutable-math.\n * It accepts an `Iterable` of the data you wish to operate on,\n * and returns the result of the function you're calling.\n *\n * For example, one way to use `average` is to call it, passing in any parameters required (`average requires no extra params`), then call the returned function passing in your data.\n *\n * ```js\n * const numbers = fromJS([1,1,1,5]);\n * return average()(numbers); // returns 2\n * ```\n *\n * For any immutable-math functions that return an `Iterable`, this design of using a partially applied function allows for easy chaining by using them inside of an `update()` method, if your input `Iterable` has an update function.\n * \n * ```js\n * return fromJS([1,1,1,5])\n *     .update(exampleFunction()) // using an exampleFunction from immutable-math in a chain\n *     .sort()\n *     .toJS();\n * ```\n * \n *\n * You can also define a function to perform a specific operation, and use it multiple times by passing in different input data.\n * \n * \n *  ```js\n * const numbersA = fromJS([\n *  {num: 1},\n *  {num: 1},\n *  {num: 1},\n *  {num: 5}\n * ]);\n * \n * const numbersB = fromJS([\n *  {num: 3},\n *  {num: 5}\n * ]);\n * \n * const averageByNum = averageBy(ii => ii.get('num'));\n * const averageA = numbersA.update(averageByNum); // averageA is 2\n * const averageB = numbersB.update(averageByNum); // averageB is 4\n * ```\n *\n * @callback InputFunction\n * @param {Iterable} input The input Iterable to be processed by one of the functions.\n * @return {Number} The result of the function\n */"}}},"description":"<p>A partially applied function which accepts a single <code>Iterable</code>, and returns the result of the operation.</p>"}],"meta":{"range":[1498,1563],"filename":"aggregations.js","lineno":53,"path":"/Users/damienclarke/projects/immutable-math/src","code":{"id":"astnode100000833","name":"meanBy","type":"FunctionDeclaration","paramnames":["valueMapper"]}},"params":[{"type":{"names":["ValueMapper"],"typedefs":{"ValueMapper":{"returns":[{"type":{"names":["Number"]},"description":"<p>The number to use in the operation.</p>"}],"meta":{"range":[5226,5684],"filename":"aggregations.js","lineno":171,"path":"/Users/damienclarke/projects/immutable-math/src","code":{}},"params":[{"type":{"names":["*"]},"description":"<p>The value of the current item in the input <code>Iterable</code>.</p>","name":"value"},{"type":{"names":["*"]},"description":"<p>The key of the current item in the input <code>Iterable</code>.</p>","name":"key"},{"type":{"names":["Iterable"]},"description":"<p>The original <code>input</code> <code>Iterable</code>.</p>","name":"iter"}],"longname":"module:aggregations~ValueMapper","name":"ValueMapper","memberof":"module:aggregations","scope":"inner","kind":"typedef","___s":true,"___id":"T000002R000041","type":{"names":["function"]},"description":"<p>A function required by some operations that allows you to specify what value gets pulled from each item in the input <code>Iterable</code> when performing a calculation.</p>","comment":"/**\n * A function required by some operations that allows you to specify what value gets pulled from each item in the input `Iterable` when performing a calculation.\n *\n * @callback ValueMapper\n * @param {*} value The value of the current item in the input `Iterable`.\n * @param {*} key The key of the current item in the input `Iterable`.\n * @param {Iterable} iter The original `input` `Iterable`.\n * @return {Number} The number to use in the operation.\n */"}}},"description":"<p>A function that allows you to specify what value gets averaged on each item in the input <code>Iterable</code>.</p>","name":"valueMapper"}],"longname":"module:aggregations~meanBy","name":"meanBy","memberof":"module:aggregations","scope":"inner","kind":"function","___s":true,"___id":"T000002R000033","description":"<p>An alias for averageBy.</p>","comment":"/**\n * An alias for averageBy.\n *\n * @param {ValueMapper} valueMapper A function that allows you to specify what value gets averaged on each item in the input `Iterable`.\n * @return {InputFunction} A partially applied function which accepts a single `Iterable`, and returns the result of the operation.\n */"},{"returns":[{"type":{"names":["InputFunction"],"typedefs":{"InputFunction":{"returns":[{"type":{"names":["Number"]},"description":"<p>The result of the function</p>"}],"meta":{"range":[3627,5224],"filename":"aggregations.js","lineno":123,"path":"/Users/damienclarke/projects/immutable-math/src","code":{}},"params":[{"type":{"names":["Iterable"]},"description":"<p>The input Iterable to be processed by one of the functions.</p>","name":"input"}],"longname":"module:aggregations~InputFunction","name":"InputFunction","memberof":"module:aggregations","scope":"inner","kind":"typedef","___s":true,"___id":"T000002R000040","type":{"names":["function"]},"description":"<p>InputFunction is a partially applied function returned from aggregations in immutable-math.\nIt accepts an <code>Iterable</code> of the data you wish to operate on,\nand returns the result of the function you're calling.</p>\n<p>For example, one way to use <code>average</code> is to call it, passing in any parameters required (<code>average requires no extra params</code>), then call the returned function passing in your data.</p>\n<pre class=\"prettyprint source lang-js\"><code>const numbers = fromJS([1,1,1,5]);\nreturn average()(numbers); // returns 2</code></pre><p>For any immutable-math functions that return an <code>Iterable</code>, this design of using a partially applied function allows for easy chaining by using them inside of an <code>update()</code> method, if your input <code>Iterable</code> has an update function.</p>\n<pre class=\"prettyprint source lang-js\"><code>return fromJS([1,1,1,5])\n    .update(exampleFunction()) // using an exampleFunction from immutable-math in a chain\n    .sort()\n    .toJS();</code></pre><p>You can also define a function to perform a specific operation, and use it multiple times by passing in different input data.</p>\n<pre class=\"prettyprint source lang-js\"><code>const numbersA = fromJS([\n {num: 1},\n {num: 1},\n {num: 1},\n {num: 5}\n]);\n\nconst numbersB = fromJS([\n {num: 3},\n {num: 5}\n]);\n\nconst averageByNum = averageBy(ii => ii.get('num'));\nconst averageA = numbersA.update(averageByNum); // averageA is 2\nconst averageB = numbersB.update(averageByNum); // averageB is 4</code></pre>","comment":"/**\n * InputFunction is a partially applied function returned from aggregations in immutable-math.\n * It accepts an `Iterable` of the data you wish to operate on,\n * and returns the result of the function you're calling.\n *\n * For example, one way to use `average` is to call it, passing in any parameters required (`average requires no extra params`), then call the returned function passing in your data.\n *\n * ```js\n * const numbers = fromJS([1,1,1,5]);\n * return average()(numbers); // returns 2\n * ```\n *\n * For any immutable-math functions that return an `Iterable`, this design of using a partially applied function allows for easy chaining by using them inside of an `update()` method, if your input `Iterable` has an update function.\n * \n * ```js\n * return fromJS([1,1,1,5])\n *     .update(exampleFunction()) // using an exampleFunction from immutable-math in a chain\n *     .sort()\n *     .toJS();\n * ```\n * \n *\n * You can also define a function to perform a specific operation, and use it multiple times by passing in different input data.\n * \n * \n *  ```js\n * const numbersA = fromJS([\n *  {num: 1},\n *  {num: 1},\n *  {num: 1},\n *  {num: 5}\n * ]);\n * \n * const numbersB = fromJS([\n *  {num: 3},\n *  {num: 5}\n * ]);\n * \n * const averageByNum = averageBy(ii => ii.get('num'));\n * const averageA = numbersA.update(averageByNum); // averageA is 2\n * const averageB = numbersB.update(averageByNum); // averageB is 4\n * ```\n *\n * @callback InputFunction\n * @param {Iterable} input The input Iterable to be processed by one of the functions.\n * @return {Number} The result of the function\n */"}}},"description":"<p>A partially applied function which accepts a single <code>Iterable</code>, and returns the result of the operation.</p>"}],"meta":{"range":[1775,2069],"filename":"aggregations.js","lineno":63,"path":"/Users/damienclarke/projects/immutable-math/src","code":{"id":"astnode100000841","name":"median","type":"FunctionDeclaration","paramnames":[]},"vars":{"":null}},"params":[],"longname":"module:aggregations~median","name":"median","memberof":"module:aggregations","scope":"inner","kind":"function","___s":true,"___id":"T000002R000034","description":"<p>Averages the elements in an <code>Iterable</code>. Accepts no parameters.</p>","comment":"/**\n * Averages the elements in an `Iterable`. Accepts no parameters.\n *\n * @return {InputFunction} A partially applied function which accepts a single `Iterable`, and returns the result of the operation.\n */"},{"returns":[{"type":{"names":["InputFunction"],"typedefs":{"InputFunction":{"returns":[{"type":{"names":["Number"]},"description":"<p>The result of the function</p>"}],"meta":{"range":[3627,5224],"filename":"aggregations.js","lineno":123,"path":"/Users/damienclarke/projects/immutable-math/src","code":{}},"params":[{"type":{"names":["Iterable"]},"description":"<p>The input Iterable to be processed by one of the functions.</p>","name":"input"}],"longname":"module:aggregations~InputFunction","name":"InputFunction","memberof":"module:aggregations","scope":"inner","kind":"typedef","___s":true,"___id":"T000002R000040","type":{"names":["function"]},"description":"<p>InputFunction is a partially applied function returned from aggregations in immutable-math.\nIt accepts an <code>Iterable</code> of the data you wish to operate on,\nand returns the result of the function you're calling.</p>\n<p>For example, one way to use <code>average</code> is to call it, passing in any parameters required (<code>average requires no extra params</code>), then call the returned function passing in your data.</p>\n<pre class=\"prettyprint source lang-js\"><code>const numbers = fromJS([1,1,1,5]);\nreturn average()(numbers); // returns 2</code></pre><p>For any immutable-math functions that return an <code>Iterable</code>, this design of using a partially applied function allows for easy chaining by using them inside of an <code>update()</code> method, if your input <code>Iterable</code> has an update function.</p>\n<pre class=\"prettyprint source lang-js\"><code>return fromJS([1,1,1,5])\n    .update(exampleFunction()) // using an exampleFunction from immutable-math in a chain\n    .sort()\n    .toJS();</code></pre><p>You can also define a function to perform a specific operation, and use it multiple times by passing in different input data.</p>\n<pre class=\"prettyprint source lang-js\"><code>const numbersA = fromJS([\n {num: 1},\n {num: 1},\n {num: 1},\n {num: 5}\n]);\n\nconst numbersB = fromJS([\n {num: 3},\n {num: 5}\n]);\n\nconst averageByNum = averageBy(ii => ii.get('num'));\nconst averageA = numbersA.update(averageByNum); // averageA is 2\nconst averageB = numbersB.update(averageByNum); // averageB is 4</code></pre>","comment":"/**\n * InputFunction is a partially applied function returned from aggregations in immutable-math.\n * It accepts an `Iterable` of the data you wish to operate on,\n * and returns the result of the function you're calling.\n *\n * For example, one way to use `average` is to call it, passing in any parameters required (`average requires no extra params`), then call the returned function passing in your data.\n *\n * ```js\n * const numbers = fromJS([1,1,1,5]);\n * return average()(numbers); // returns 2\n * ```\n *\n * For any immutable-math functions that return an `Iterable`, this design of using a partially applied function allows for easy chaining by using them inside of an `update()` method, if your input `Iterable` has an update function.\n * \n * ```js\n * return fromJS([1,1,1,5])\n *     .update(exampleFunction()) // using an exampleFunction from immutable-math in a chain\n *     .sort()\n *     .toJS();\n * ```\n * \n *\n * You can also define a function to perform a specific operation, and use it multiple times by passing in different input data.\n * \n * \n *  ```js\n * const numbersA = fromJS([\n *  {num: 1},\n *  {num: 1},\n *  {num: 1},\n *  {num: 5}\n * ]);\n * \n * const numbersB = fromJS([\n *  {num: 3},\n *  {num: 5}\n * ]);\n * \n * const averageByNum = averageBy(ii => ii.get('num'));\n * const averageA = numbersA.update(averageByNum); // averageA is 2\n * const averageB = numbersB.update(averageByNum); // averageB is 4\n * ```\n *\n * @callback InputFunction\n * @param {Iterable} input The input Iterable to be processed by one of the functions.\n * @return {Number} The result of the function\n */"}}},"description":"<p>A partially applied function which accepts a single <code>Iterable</code>, and returns the result of the operation.</p>"}],"meta":{"range":[2478,2590],"filename":"aggregations.js","lineno":81,"path":"/Users/damienclarke/projects/immutable-math/src","code":{"id":"astnode100000907","name":"medianBy","type":"FunctionDeclaration","paramnames":["valueMapper"]},"vars":{"":null}},"params":[{"type":{"names":["ValueMapper"],"typedefs":{"ValueMapper":{"returns":[{"type":{"names":["Number"]},"description":"<p>The number to use in the operation.</p>"}],"meta":{"range":[5226,5684],"filename":"aggregations.js","lineno":171,"path":"/Users/damienclarke/projects/immutable-math/src","code":{}},"params":[{"type":{"names":["*"]},"description":"<p>The value of the current item in the input <code>Iterable</code>.</p>","name":"value"},{"type":{"names":["*"]},"description":"<p>The key of the current item in the input <code>Iterable</code>.</p>","name":"key"},{"type":{"names":["Iterable"]},"description":"<p>The original <code>input</code> <code>Iterable</code>.</p>","name":"iter"}],"longname":"module:aggregations~ValueMapper","name":"ValueMapper","memberof":"module:aggregations","scope":"inner","kind":"typedef","___s":true,"___id":"T000002R000041","type":{"names":["function"]},"description":"<p>A function required by some operations that allows you to specify what value gets pulled from each item in the input <code>Iterable</code> when performing a calculation.</p>","comment":"/**\n * A function required by some operations that allows you to specify what value gets pulled from each item in the input `Iterable` when performing a calculation.\n *\n * @callback ValueMapper\n * @param {*} value The value of the current item in the input `Iterable`.\n * @param {*} key The key of the current item in the input `Iterable`.\n * @param {Iterable} iter The original `input` `Iterable`.\n * @return {Number} The number to use in the operation.\n */"}}},"description":"<p>A function that allows you to specify what value gets read from each item in the input <code>Iterable</code>.</p>","name":"valueMapper"}],"longname":"module:aggregations~medianBy","name":"medianBy","memberof":"module:aggregations","scope":"inner","kind":"function","___s":true,"___id":"T000002R000037","description":"<p>Like <code>median</code>, but also accepts a <code>valueMapper</code> function which allows for determning the median by more sophisticated means.</p>","comment":"/**\n * Like `median`, but also accepts a `valueMapper` function which allows for determning the median by more sophisticated means.\n *\n * @param {ValueMapper} valueMapper A function that allows you to specify what value gets read from each item in the input `Iterable`.\n * @return {InputFunction} A partially applied function which accepts a single `Iterable`, and returns the result of the operation.\n */"},{"returns":[{"type":{"names":["InputFunction"],"typedefs":{"InputFunction":{"returns":[{"type":{"names":["Number"]},"description":"<p>The result of the function</p>"}],"meta":{"range":[3627,5224],"filename":"aggregations.js","lineno":123,"path":"/Users/damienclarke/projects/immutable-math/src","code":{}},"params":[{"type":{"names":["Iterable"]},"description":"<p>The input Iterable to be processed by one of the functions.</p>","name":"input"}],"longname":"module:aggregations~InputFunction","name":"InputFunction","memberof":"module:aggregations","scope":"inner","kind":"typedef","___s":true,"___id":"T000002R000040","type":{"names":["function"]},"description":"<p>InputFunction is a partially applied function returned from aggregations in immutable-math.\nIt accepts an <code>Iterable</code> of the data you wish to operate on,\nand returns the result of the function you're calling.</p>\n<p>For example, one way to use <code>average</code> is to call it, passing in any parameters required (<code>average requires no extra params</code>), then call the returned function passing in your data.</p>\n<pre class=\"prettyprint source lang-js\"><code>const numbers = fromJS([1,1,1,5]);\nreturn average()(numbers); // returns 2</code></pre><p>For any immutable-math functions that return an <code>Iterable</code>, this design of using a partially applied function allows for easy chaining by using them inside of an <code>update()</code> method, if your input <code>Iterable</code> has an update function.</p>\n<pre class=\"prettyprint source lang-js\"><code>return fromJS([1,1,1,5])\n    .update(exampleFunction()) // using an exampleFunction from immutable-math in a chain\n    .sort()\n    .toJS();</code></pre><p>You can also define a function to perform a specific operation, and use it multiple times by passing in different input data.</p>\n<pre class=\"prettyprint source lang-js\"><code>const numbersA = fromJS([\n {num: 1},\n {num: 1},\n {num: 1},\n {num: 5}\n]);\n\nconst numbersB = fromJS([\n {num: 3},\n {num: 5}\n]);\n\nconst averageByNum = averageBy(ii => ii.get('num'));\nconst averageA = numbersA.update(averageByNum); // averageA is 2\nconst averageB = numbersB.update(averageByNum); // averageB is 4</code></pre>","comment":"/**\n * InputFunction is a partially applied function returned from aggregations in immutable-math.\n * It accepts an `Iterable` of the data you wish to operate on,\n * and returns the result of the function you're calling.\n *\n * For example, one way to use `average` is to call it, passing in any parameters required (`average requires no extra params`), then call the returned function passing in your data.\n *\n * ```js\n * const numbers = fromJS([1,1,1,5]);\n * return average()(numbers); // returns 2\n * ```\n *\n * For any immutable-math functions that return an `Iterable`, this design of using a partially applied function allows for easy chaining by using them inside of an `update()` method, if your input `Iterable` has an update function.\n * \n * ```js\n * return fromJS([1,1,1,5])\n *     .update(exampleFunction()) // using an exampleFunction from immutable-math in a chain\n *     .sort()\n *     .toJS();\n * ```\n * \n *\n * You can also define a function to perform a specific operation, and use it multiple times by passing in different input data.\n * \n * \n *  ```js\n * const numbersA = fromJS([\n *  {num: 1},\n *  {num: 1},\n *  {num: 1},\n *  {num: 5}\n * ]);\n * \n * const numbersB = fromJS([\n *  {num: 3},\n *  {num: 5}\n * ]);\n * \n * const averageByNum = averageBy(ii => ii.get('num'));\n * const averageA = numbersA.update(averageByNum); // averageA is 2\n * const averageB = numbersB.update(averageByNum); // averageB is 4\n * ```\n *\n * @callback InputFunction\n * @param {Iterable} input The input Iterable to be processed by one of the functions.\n * @return {Number} The result of the function\n */"}}},"description":"<p>A partially applied function which accepts a single <code>Iterable</code>, and returns the result of the operation.</p>"}],"meta":{"range":[2794,2926],"filename":"aggregations.js","lineno":93,"path":"/Users/damienclarke/projects/immutable-math/src","code":{"id":"astnode100000924","name":"sum","type":"FunctionDeclaration","paramnames":[]},"vars":{"":null}},"params":[],"longname":"module:aggregations~sum","name":"sum","memberof":"module:aggregations","scope":"inner","kind":"function","___s":true,"___id":"T000002R000038","description":"<p>Sums the elements in an <code>Iterable</code>. Accepts no parameters.</p>","comment":"/**\n* Sums the elements in an `Iterable`. Accepts no parameters.\n*\n* @return {InputFunction} A partially applied function which accepts a single `Iterable`, and returns the result of the operation.\n*/"},{"returns":[{"type":{"names":["InputFunction"],"typedefs":{"InputFunction":{"returns":[{"type":{"names":["Number"]},"description":"<p>The result of the function</p>"}],"meta":{"range":[3627,5224],"filename":"aggregations.js","lineno":123,"path":"/Users/damienclarke/projects/immutable-math/src","code":{}},"params":[{"type":{"names":["Iterable"]},"description":"<p>The input Iterable to be processed by one of the functions.</p>","name":"input"}],"longname":"module:aggregations~InputFunction","name":"InputFunction","memberof":"module:aggregations","scope":"inner","kind":"typedef","___s":true,"___id":"T000002R000040","type":{"names":["function"]},"description":"<p>InputFunction is a partially applied function returned from aggregations in immutable-math.\nIt accepts an <code>Iterable</code> of the data you wish to operate on,\nand returns the result of the function you're calling.</p>\n<p>For example, one way to use <code>average</code> is to call it, passing in any parameters required (<code>average requires no extra params</code>), then call the returned function passing in your data.</p>\n<pre class=\"prettyprint source lang-js\"><code>const numbers = fromJS([1,1,1,5]);\nreturn average()(numbers); // returns 2</code></pre><p>For any immutable-math functions that return an <code>Iterable</code>, this design of using a partially applied function allows for easy chaining by using them inside of an <code>update()</code> method, if your input <code>Iterable</code> has an update function.</p>\n<pre class=\"prettyprint source lang-js\"><code>return fromJS([1,1,1,5])\n    .update(exampleFunction()) // using an exampleFunction from immutable-math in a chain\n    .sort()\n    .toJS();</code></pre><p>You can also define a function to perform a specific operation, and use it multiple times by passing in different input data.</p>\n<pre class=\"prettyprint source lang-js\"><code>const numbersA = fromJS([\n {num: 1},\n {num: 1},\n {num: 1},\n {num: 5}\n]);\n\nconst numbersB = fromJS([\n {num: 3},\n {num: 5}\n]);\n\nconst averageByNum = averageBy(ii => ii.get('num'));\nconst averageA = numbersA.update(averageByNum); // averageA is 2\nconst averageB = numbersB.update(averageByNum); // averageB is 4</code></pre>","comment":"/**\n * InputFunction is a partially applied function returned from aggregations in immutable-math.\n * It accepts an `Iterable` of the data you wish to operate on,\n * and returns the result of the function you're calling.\n *\n * For example, one way to use `average` is to call it, passing in any parameters required (`average requires no extra params`), then call the returned function passing in your data.\n *\n * ```js\n * const numbers = fromJS([1,1,1,5]);\n * return average()(numbers); // returns 2\n * ```\n *\n * For any immutable-math functions that return an `Iterable`, this design of using a partially applied function allows for easy chaining by using them inside of an `update()` method, if your input `Iterable` has an update function.\n * \n * ```js\n * return fromJS([1,1,1,5])\n *     .update(exampleFunction()) // using an exampleFunction from immutable-math in a chain\n *     .sort()\n *     .toJS();\n * ```\n * \n *\n * You can also define a function to perform a specific operation, and use it multiple times by passing in different input data.\n * \n * \n *  ```js\n * const numbersA = fromJS([\n *  {num: 1},\n *  {num: 1},\n *  {num: 1},\n *  {num: 5}\n * ]);\n * \n * const numbersB = fromJS([\n *  {num: 3},\n *  {num: 5}\n * ]);\n * \n * const averageByNum = averageBy(ii => ii.get('num'));\n * const averageA = numbersA.update(averageByNum); // averageA is 2\n * const averageB = numbersB.update(averageByNum); // averageB is 4\n * ```\n *\n * @callback InputFunction\n * @param {Iterable} input The input Iterable to be processed by one of the functions.\n * @return {Number} The result of the function\n */"}}},"description":"<p>A partially applied function which accepts a single <code>Iterable</code>, and returns the result of the operation.</p>"}],"meta":{"range":[3318,3424],"filename":"aggregations.js","lineno":108,"path":"/Users/damienclarke/projects/immutable-math/src","code":{"id":"astnode100000945","name":"sumBy","type":"FunctionDeclaration","paramnames":["valueMapper"]},"vars":{"":null}},"params":[{"type":{"names":["ValueMapper"],"typedefs":{"ValueMapper":{"returns":[{"type":{"names":["Number"]},"description":"<p>The number to use in the operation.</p>"}],"meta":{"range":[5226,5684],"filename":"aggregations.js","lineno":171,"path":"/Users/damienclarke/projects/immutable-math/src","code":{}},"params":[{"type":{"names":["*"]},"description":"<p>The value of the current item in the input <code>Iterable</code>.</p>","name":"value"},{"type":{"names":["*"]},"description":"<p>The key of the current item in the input <code>Iterable</code>.</p>","name":"key"},{"type":{"names":["Iterable"]},"description":"<p>The original <code>input</code> <code>Iterable</code>.</p>","name":"iter"}],"longname":"module:aggregations~ValueMapper","name":"ValueMapper","memberof":"module:aggregations","scope":"inner","kind":"typedef","___s":true,"___id":"T000002R000041","type":{"names":["function"]},"description":"<p>A function required by some operations that allows you to specify what value gets pulled from each item in the input <code>Iterable</code> when performing a calculation.</p>","comment":"/**\n * A function required by some operations that allows you to specify what value gets pulled from each item in the input `Iterable` when performing a calculation.\n *\n * @callback ValueMapper\n * @param {*} value The value of the current item in the input `Iterable`.\n * @param {*} key The key of the current item in the input `Iterable`.\n * @param {Iterable} iter The original `input` `Iterable`.\n * @return {Number} The number to use in the operation.\n */"}}},"description":"<p>A function that allows you to specify what value gets summed on each item in the input <code>Iterable</code>.</p>","name":"valueMapper"}],"longname":"module:aggregations~sumBy","name":"sumBy","memberof":"module:aggregations","scope":"inner","kind":"function","___s":true,"___id":"T000002R000039","description":"<p>Like <code>sum</code>, but also accepts a <code>valueMapper</code> function which allows for summing by more sophisticated means.</p>","comment":"/**\n * Like `sum`, but also accepts a `valueMapper` function which allows for summing by more sophisticated means.\n *\n * @param {ValueMapper} valueMapper A function that allows you to specify what value gets summed on each item in the input `Iterable`.\n * @return {InputFunction} A partially applied function which accepts a single `Iterable`, and returns the result of the operation.\n */"}]}]}}